<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>D3 Tree Visualization</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #treeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #nodeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
            pointer-events: none; /* Allows canvas interactions through overlay */
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
</head>
<body>
    <canvas id="treeCanvas"></canvas>
    <div id="nodeOverlay"></div> <!-- Overlay for interactive elements -->

    <script>
        // Sample Data
        const treeData = {{ tree|safe }};

        // Set up canvas
        const canvas = document.getElementById('treeCanvas');
        const context = canvas.getContext('2d');
        const overlay = document.getElementById('nodeOverlay');

        // Set canvas to full screen size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Tree dimensions
        const treeWidth = 20000;
        const treeHeight = 800;

        // Create a D3 tree layout
        const treeLayout = d3.tree().size([treeWidth, treeHeight]);

        // Create a D3 hierarchy
        const rootHierarchy = d3.hierarchy(treeData);

        // Generate the tree
        const tree = treeLayout(rootHierarchy);

        // Variables for panning
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let startX, startY;

        // Interactive state
        let hoveredNode = null;
        let clickedNode = null;

        // Offscreen canvas for optimized drawing
        const offscreenCanvas = document.createElement('canvas');
        const offscreenContext = offscreenCanvas.getContext('2d');
        offscreenCanvas.width = canvas.width;
        offscreenCanvas.height = canvas.height;

        function drawTree() {
            offscreenContext.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenContext.save();
            offscreenContext.translate(offsetX, offsetY);

            // Draw the links
            offscreenContext.strokeStyle = '#aaa';
            offscreenContext.lineWidth = 2;
            tree.links().forEach(link => {
                offscreenContext.beginPath();
                offscreenContext.moveTo(link.source.x, link.source.y);
                offscreenContext.lineTo(link.target.x, link.target.y);
                offscreenContext.stroke();
            });

            // Draw the nodes
            tree.descendants().forEach(node => {
                offscreenContext.beginPath();
                const isHovered = hoveredNode === node;
                const isClicked = clickedNode === node;
                offscreenContext.arc(node.x, node.y, 10, 0, 2 * Math.PI);
                offscreenContext.fillStyle = isClicked ? '#f00' : (isHovered ? '#0f0' : '#000');
                offscreenContext.fill();
                offscreenContext.textAlign = 'start';
                offscreenContext.fillStyle = '#fff';
                offscreenContext.font = isHovered ? 'bold 12px Arial' : '12px Arial';
                offscreenContext.fillText(node.data.first_name, node.x + 15, node.y + 5);
            });

            offscreenContext.restore();

            // Copy offscreen canvas to visible canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(offscreenCanvas, 0, 0);
        }

        // Throttle the drawing updates
        let isDrawing = false;
        function throttleDraw() {
            if (isDrawing) return;
            isDrawing = true;
            requestAnimationFrame(() => {
                drawTree();
                isDrawing = false;
            });
        }

        // Draw the tree initially
        drawTree();

        // Handle panning with mouse and touch
        canvas.addEventListener('mousedown', (event) => {
            isPanning = true;
            startX = event.clientX - offsetX;
            startY = event.clientY - offsetY;
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isPanning) {
                offsetX = event.clientX - startX;
                offsetY = event.clientY - startY;
                throttleDraw();
            } else {
                // Detect hover
                const mouseX = event.clientX - offsetX;
                const mouseY = event.clientY - offsetY;
                hoveredNode = null;
                tree.descendants().forEach(node => {
                    const dx = node.x - mouseX;
                    const dy = node.y - mouseY;
                    if (dx * dx + dy * dy < 10 * 10) {  // 10px radius
                        hoveredNode = node;
                    }
                });
                throttleDraw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isPanning = false;
        });

        canvas.addEventListener('mouseout', () => {
            isPanning = false;
        });

        // Handle touch events
        canvas.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isPanning = true;
                const touch = event.touches[0];
                startX = touch.clientX - offsetX;
                startY = touch.clientY - offsetY;
            }
        });

        canvas.addEventListener('touchmove', (event) => {
            if (isPanning && event.touches.length === 1) {
                const touch = event.touches[0];
                offsetX = touch.clientX - startX;
                offsetY = touch.clientY - startY;
                throttleDraw();
            }
        });

        canvas.addEventListener('touchend', () => {
            isPanning = false;
        });

        // Handle clicks
        canvas.addEventListener('click', (event) => {
            const mouseX = event.clientX - offsetX;
            const mouseY = event.clientY - offsetY;
            clickedNode = null;
            tree.descendants().forEach(node => {
                const dx = node.x - mouseX;
                const dy = node.y - mouseY;
                if (dx * dx + dy * dy < 10 * 10) {  // 10px radius
                    clickedNode = node;
                }
            });
            throttleDraw();
        });

        // Adjust canvas on window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            throttleDraw();
        });
    </script>
</body>
</html>
